// Sty2Clip.cpp - turn .sty files into .mid files in clip
//                and .txt files too

#include "rc\resource.h"
#include "ui.h"
#include "MidiIO.h"

const ulong MAX_EV  = 512*1024;        // max events
const uword MAX_TXT = 320;             // max text event buffer len

typedef struct {ulong tBgn, tEnd, eBgn, eEnd;} ScVaDef;

typedef struct {                       // need a "broader" TrkEv in here
   ulong time;
   ubyte chan;                         // 0..15 (device ignored here)
   ulong prog;                         // prog<<16 | bnkH<<8 | bnkL
   uword ctrl;                         // scVa,prog set after mid loads
   ubyte valu, val2;
} EvDef;

typedef struct {
   TStr  name;
   ulong end;
} TrDef;

typedef struct {
   ubyte chan;
   ulong prog;
   ulong time;
} PrDef;

typedef struct {ulong time;  TStr s;}  TxDef;


//______________________________________________________________________________
ScVaDef ScVa   [4*8];                  // and Seg[] below...
EvDef   Ev     [MAX_EV];   ulong NEv;  // buf w parsed midi events
TrkEv   TE [16][MAX_EV];   ulong NTE [16];  // out trks for one of the CH_*s

// reused per sty file
bool   Bad;                            // if couldn't parse FN :(
ubyte  Mid [1024*1024];                // mem to hold the whole .Sty file
ulong  MidLen, MidPos;                 // len of buf and pos we're parsin' at
TStr   FN, FsBuf, Tmpo, TMS;
ubyte  ProgCh [16], TSigN, TSigD;
TrDef  Tr;                             // track(only 1 ever)
PrDef  Pr [16384];     ulong NPr;      // program change info
TxDef  Mk [MAX_LYR];   ulong NMk;      // buf w marker events

// consant-ish stuphs
char  *Desc  [] = {"","Text","Copyright","Track","Instrument",
                      "Lyric","Marker","Cue","Sound","Device",
                      "Text10","Text11","Text12","Text13","Text14","Text15"},
      *KyStr [2][2][8] = {{{"x", "G", "D", "A", "E", "B", "F#","C#"},      // M#
                           {"C", "F", "Bb","Eb","Ab","Db","Gb","Cb"}},     // Mb
                          {{"x", "E", "B", "F#","C#","G#","D#","A#"},      // m#
                           {"A", "D", "G", "C", "F", "Bb","Eb","Ab"}}},    // mb
       KyNum [2][2][8] = {{{M_C, M_G, M_D, M_A, M_E, M_B, M_Fs,M_Cs},      // M#
                           {M_C, M_F, M_Bb,M_Eb,M_Ab,M_Db,M_Gb,M_Cb}},     // Mb
                          {{M_A, M_E, M_B, M_Gb,M_Cs,M_Gs,M_Ds,M_As},      // m#
                           {M_A, M_D, M_G, M_C, M_F, M_Bb,M_Eb,M_Ab}}};    // mb


void Puke (char *e, char *e2 = NULL)
// file has broke format - rename to fn.bad, write why in fn.bad.txt
{ TStr fn2;
  File f;
   Bad = true;
   StrCp (fn2, FN);   StrAp (fn2, ".BAD");   f.ReNm (FN, fn2);
   StrAp (fn2, ".txt");                         DBG("RATSSS");
   if (f.Open (fn2, "w")) {
                f.Put (e);    f.Put ("\r\n");   DBG(e);
      if (e2)  {f.Put (e2);   f.Put ("\r\n");   DBG(e2);}
      f.Shut ();
   }
}


char *TmSt (char *str, ulong tm)       // HACK fer debuggin :/
{ ulong dBr, dBt, bx;
  uword    s = 0, br, bt;
   dBt = M_WHOLE / TSigD;
   dBr = dBt     * TSigN;
   br  = (uword)(1 +  tm / dBr);
   bt  = (uword)(1 + (tm % dBr) / dBt);
   bx  =             (tm % dBr) % dBt;
   return StrFmt (str, "`04d.`d.`d(`d)=`d", br, bt, bx, bx*100/dBt, tm);
}


//______________________________________________________________________________
// track readin dudes
void GetByt (ulong *p, ulong l, ubyte *it)
{ static TStr err;
   if (*p >= l)  return Puke (StrFmt (err,
      "EndOfTrack but expectin a byte...:(p=`d l=`d ofs=`d)",
      *p, l, MidPos+*p));
   *it = Mid [MidPos + *p];  (*p)++;
}

void GetVar (ulong *p, ulong l, ulong *it, char *kinda)
// Read oneuh those wierd variable length numbers...
{ ulong val = 0, len = 0;
  ubyte b;
  static TStr err;
   do {
      if (*p >= l)  return Puke (StrFmt (err,
         "EndOfTrack on `s VarLen param...:(p=`d l=`d ofs=`d)",
         kinda, *p, l, MidPos+*p));
      val = (val << 7) | ((b = Mid [MidPos + (*p)++]) & 0x7F);
      if (++len > 4)  return Puke (StrFmt (err,
         "Bad `s VarLen param...:(p=`d l=`d len=`d ofs=`d)",
         kinda, *p, l, len, MidPos+*p));
   } while (b & 0x80);
   *it = val;
}

void Skip (ulong *p, ulong l, ulong skp)
{  if ((*p += skp) >= l)  return Puke ("Hit EndOfTrack skippin stuff");  }

void FixStrLy (ubyte *s, ubyte l)
{ ulong c;
   s [l] = '\0';
   for (c = 0; c < l; c++) {
      if ((s [c] == '@') || (s [c] == '\r') || (s [c] == '\n') ||
          (s [c] == '/') || (s [c] == '\\'))  s [c] = '/';
      if ((s [c] <= ' ') || (s [c] > '~'))    s [c] = '_';
   }
}

void FixStr1 (ubyte *s, ubyte l)
{ ulong c;
   s [l] = '\0';
   for (c = 0; c < l; c++)  if ((s [c] < ' ') || (s [c] > '~'))  s [c] = '_';
}

void FixStr2 (ubyte *s, ubyte l)
{ ulong c;
   for (c = 0; c < l; c++)  if (s [c] == ' ')  s [c] = '_';
   if (l)  {l--;  while (l && (s [l] == '_')) l--;  s [l+1] = '\0';}
}


//______________________________________________________________________________
void Trk2Ev (uword res, ulong l)
// load a midi track into e and print text info, etc in song file
{ ulong p;                      // parse pos (offset from MidPos)
  ulong delta, ftime, time;     // delta => filetime*res => time
  ubyte pStat;                  // midi running status byte
  char  strbuf [MAX_TXT+1], trknm [4+MAX_TXT+4+1], ptrknm;
  ulong hmmlen, hmmgot, i, j;
  ubyte c, tc, minr, flat, regParm [256*16][5];
  sbyte num;
  ubyte chan;
  ubyte chopln;
  char  gotKar = 0;
  TStr  chop;
  ulong prog [256*16];
//DBG("{ Trk2Ev");
// remember track name and which kind of name it was (to pick best one)
   trknm [0] = '\0';  ptrknm = 0;

// init filetime and running status
   ftime = 0;  pStat = 0;  chan = 0;  MemSet (prog, 0, sizeof (prog));
   MemSet (regParm, 0, sizeof (regParm));

   for (p = 0;  p < l;) {
      GetVar (& p, l, & delta, "deltatime");   if (Bad) return;

      ftime += delta;  time = (ftime * 192) / res;
//DBG("MidPos=`d(p=`d/l=`d) delta=`d res=`d=> time=`s",
//MidPos+p, p, l, delta, res, TmS(TMS,time));
      GetByt (& p, l, & c);   if (Bad) return;

//DBG("   c=$`02x", c);
      if (c == 0xFF) {
      // parse those damn midifile "meta" events
      // 0=SeqNo, 1=Text, 2=Copyright, 3=SeqName/TrackName, 4=Instrument,
      // 5=Lyric, 6=Marker, 7=CuePoint, 8=Program(Patch), 9=Device(Port),
      // $20=cakewalkChan, $21=cakewalkPort,
      // $2F=EndOfTrack, $51=Tempo, $54=SMPTEOffset, $58=TimeSig, $59=KeySig
         pStat = 0;
         GetByt (& p, l, & c);                if (Bad) return;

         GetVar (& p, l, & hmmlen, "text");   if (Bad) return;

         if ((p + hmmlen) > l)
            return Puke ("Trk2Ev  EndOfTrack readin a $FF??");
         switch (c) {
            case 0:   //...sequence number
//               if (hmmlen == 2)
//DBG("`s: SeqNo=`d",
//TmS(TMS,time), Mid [MidPos+p]<<8 | Mid [MidPos+p+1]);
//               else
//DBG("`s: SeqNo=(here)", TmS(TMS,time));
               break;
            case 5:   //...LYRIC text event
               hmmgot = (hmmlen > MAX_TXT) ? MAX_TXT : hmmlen;
               MemCp (strbuf, & Mid [MidPos+p], hmmgot);
               FixStrLy ((ubyte *) strbuf, (ubyte) hmmgot);
               break;                  // just skip em
            case 6:   //...MARKER text event
               hmmgot = (hmmlen > MAX_TXT) ? MAX_TXT : hmmlen;
               MemCp (strbuf, & Mid [MidPos+p], hmmgot);
               FixStrLy ((ubyte *) strbuf, (ubyte) hmmgot);
               if (*strbuf == '\0')   StrCp (strbuf, "-");
               if (NMk >= BITS (Mk))  break;
//DBG("`s: marker[`d]=`s", TmS (TMS,time), NMk, strbuf);
               Mk [NMk].time = time;
               StrCp (Mk [NMk].s, strbuf);
               NMk++;
               break;
            case 9:   //...DevName text event - skip it
               hmmgot = (hmmlen > MAX_TXT) ? MAX_TXT : hmmlen;
               MemCp (strbuf, & Mid [MidPos+p], hmmgot);
               strbuf [hmmgot] = '\0';
               if (*strbuf == '\0')   StrCp (strbuf, "00");
//             chan = (uword)((i << 4) | (chan & 0x0F));
//DBG("`s: Device=`s  (chan=`d)\r\n",
//TmS (TMS,time), strbuf, chan+1);
               break;
            case 1:   case 2:   case 3:   case 4:   case 7:   case 8:
            case 10:  case 11:  case 12:  case 13:  case 14:
            case 15:  //...Text,Copyright,Seq/TrackName,Instrument,
                      //   CuePoint,Program(Patch),10-15 text events
               hmmgot = (hmmlen > MAX_TXT) ? MAX_TXT : hmmlen;
               MemCp (strbuf, & Mid [MidPos+p], hmmgot);
               FixStr1 ((ubyte *) strbuf, (ubyte) hmmgot);
               if ((c == 3) && (StrCm (strbuf, "Words", 'x') == 0))  gotKar = 1;
               if ((c == 1) && gotKar) {
                  FixStrLy ((ubyte *) strbuf, (ubyte) hmmgot);
                  break;               // just skip em
               }
               for (chopln = 0;
                    chopln < (int)(StrLn (strbuf) / 120 +
                                  (StrLn (strbuf) % 120 ? 1 : 0));
                    chopln++) {
                  MemCp (chop, & strbuf [120*chopln], 120);  chop [120] = '\0';
                  if      (c == 1)
                     StrFmt (FsBuf, "`s: `s\r\n",
                        TmS (TMS,time),            chop);
                  else if (c != 3)
                     StrFmt (FsBuf, "`s: `s=`s\r\n",
                        TmS (TMS,time), Desc [c],  chop);
                  else *FsBuf = '\0';  // no need to show track 2x
               }
               FixStr2 ((ubyte *) strbuf, (ubyte) hmmgot);
            // prefer track, then instr, then text for track's name
               switch (c) {                                        // track
                  case 3:      StrCp (trknm, strbuf);  ptrknm = c;   break;
                  case 4:  if  (ptrknm != 3)                       // instr
                              {StrCp (trknm, strbuf);  ptrknm = c;}  break;
                  case 1:  if ((ptrknm != 3) && (ptrknm != 4))     // text
                              {StrCp (trknm, strbuf);  ptrknm = c;}  break;
                  default: if ((ptrknm != 3) && (ptrknm != 4) &&
                               (ptrknm != 1) && (ptrknm == 0))
                              {StrCp (trknm, strbuf);  ptrknm = c;}
               }
//DBG("`s: `s=`s", TmS (TMS,time), Desc [c], strbuf);
               break;
            case 0x20: // INVALID(yet used) midi channel prefix (chan LSB)
                       // (chan LSB: for sysx, meta events)
               if (hmmlen == 1) {
                  chan = Mid [MidPos+p];
//DBG("`s: Chan_Cakewalk=`d  (chan=`d)\r\n",
//TmS (TMS,time), i+1, chan+1);
               }
//               else
//DBG("`s: Chan_Cakewalk=??\r\n",
//TmS (TMS,time));
               break;
            case 0x21: // INVALID(yet used) midi port prefix    (chan MSB)
               if (hmmlen == 1) {
//                i = Mid [MidPos+p];  chan = (uword)((i << 4) | (chan & 0x0F));
//DBG("`s: Port_Cakewalk=`d  (chan=`d)\r\n",
//TmS (TMS,time), i+1, chan+1);
               }
//               else
//DBG("`s: Port_Cakewalk=??\r\n",
//TmS (TMS,time));
               break;
            case 0x2F: //...End track - end time is set (REQUIRED)
//DBG("`s: EndTrack\r\n", TmS (TMS,time));
               Tr.end = time;
               break;
            case 0x51: //...Tempo
               i = Mid [MidPos+p]<<16 | Mid [MidPos+p+1]<<8 | Mid [MidPos+p+2];
               j = 60000000 / i;
               if ((60000000 % i) >= (i/2))  j++;  // round it
//DBG("`s: Tempo=`d BPM (`d uSec/Quarter)",
//TmS (TMS,time), j, i);
               if (! *Tmpo)  StrFmt (Tmpo, "`d\r\n", j);
               Ev [NEv].time = time;
               Ev [NEv].ctrl = MC_TMPO;
               Ev [NEv].valu = (ubyte)( j       & 0x00FF);
               Ev [NEv].val2 = (ubyte)((j >> 8) & 0x00FF);
               Ev [NEv].chan = chan;
               NEv++;
               break;
            case 0x54: //...SMPTE offset
//DBG("`s: SMPTEOfs=`02d:`02d:`02d.`02d.`02d\r\n",
//TmS (TMS,time), Mid [MidPos+p+0], Mid [MidPos+p+1], Mid [MidPos+p+2],
//Mid [MidPos+p+3], Mid [MidPos+p+4]);
               break;
            case 0x58: //...TimeSignature
if (time < M_WHOLE)
   {TSigN = Mid [MidPos+p+0];   TSigD = (ubyte)(1 << Mid [MidPos+p+1]);}
//DBG("`s: TimeSig=`d/`d (`d clocks/metronone, "
//"`d notated 32nd notes/24 clocks)\r\n",
//TmS (TMS,time), Mid [MidPos+p+0], 1 << Mid [MidPos+p+1],
//                Mid [MidPos+p+2],      Mid [MidPos+p+3]);
               Ev [NEv].time = time;
               Ev [NEv].ctrl = MC_TSIG;
               Ev [NEv].valu = Mid [MidPos+p+0];
               Ev [NEv].val2 = Mid [MidPos+p+1];
               if ((Ev [NEv].valu == 4) && (Ev [NEv].val2 == 2))
                  Ev [NEv].val2 |= (3 << 4);     // for 4/4, default subbeat=4
               Ev [NEv].chan = chan;
               NEv++;
               break;
            case 0x59: //...KeySignature
               num = (sbyte) Mid [MidPos+p];
               if (num <= 0)  {num = -num;  flat = 1;}  else flat = 0;
               minr = Mid [MidPos+p+1] ? 1 : 0;
//DBG("`s: KeySig=`s `s (`d `s)\r\n",
//TmS (TMS,time), KyStr [minr][flat][num],
//minr ? "Minor" : "Major", (int)num,  flat ? "Flats" : "Sharps");
               Ev [NEv].time = time;
               Ev [NEv].ctrl = MC_KSIG;
               Ev [NEv].valu = KyNum [minr][flat][num];
               Ev [NEv].val2 =       (minr?0x01:0) | (flat?0x80:0);
               Ev [NEv].chan = chan;
               NEv++;
               break;
            default:  ;
//DBG("`s: $FF`02x=(Len `d) ", TmS (TMS,time), (int)c, hmmlen);
//               for (i = 0; (i < hmmlen) && (i < 16); i++)
//DBG("`02x ", (int) Mid [MidPos+p+i]);
//               for (i = 0; (i < hmmlen) && (i < 16); i++) {
//                  tc = Mid [MidPos+p+i];
//DBG("`c", ((tc<' ') || (tc>'~')) ? '.' : tc);
//               }
         }
         p += hmmlen;
      }
      else if ((c == M_SYSX) || (c == M_EOX)) {  // ...toss sysex
      // TODO handle mastervolume,masterbalance?
      // F0,7F,7F,04,01,LSB,MSB,F7(bal=02)
         pStat = 0;
         GetVar (& p, l, & hmmlen, "sysex");   if (Bad) return;

         Skip   (& p, l,   hmmlen);            if (Bad) return;
//DBG("`s: SysEx of `d bytes tossed", TmS (TMS,time), hmmlen);
      }
      else if (c > M_SYSX) {        // ...toss realtime msg
         pStat = 0;
//DBG("SysRealtime Cmd $`02x tossed", (int)c);
         if (c == M_SONGPOS) Skip (& p, l, 2);   if (Bad) return;
         if (c == M_SONGSEL) Skip (& p, l, 1);   if (Bad) return;
      }
      else {
         if (c & 0x80)
            {pStat = c;   GetByt (& p, l, & c);   if (Bad) return;}
         chan = pStat & 0x0F;
         Ev [NEv].time = time;
         Ev [NEv].ctrl = c;
         Ev [NEv].chan = chan;
//DBG(" MIDI time=`d ctrl=`02x chan=`04x",time, c, chan);
         switch (pStat & 0xF0) {
            case M_NOTE: GetByt (& p, l, & tc);   if (Bad) return;
                         Ev [NEv].valu = tc ? (0x80 | tc) : 64;
                                            // valu of 0 means noteoff w vel=64
                         if (Ev [NEv].ctrl >= M_NT(M_C,0))  NEv++;
                         break;
            case M_NPRS: GetByt (& p, l, & tc);   if (Bad) return;
                         Ev [NEv].valu =       0x80 | tc;
                         Ev [NEv].val2 = 0x80;
                         if (Ev [NEv].ctrl >= M_NT(M_C,0)) NEv++;
                         break;
            case M_NOFF: GetByt (& p, l, & tc);   if (Bad) return;
                         Ev [NEv].valu =              tc;
                         if (Ev [NEv].ctrl >= M_NT(M_C,0)) NEv++;
                         break;
            case M_PROG: if ((chan & 0x0F) == 9)  break;  // skip drum ProgCh's
                         if (NPr == BITS (Pr))
                            return Puke ("Trk2Ev  tooo many program changes");
                         prog [chan] = (prog [chan] & 0x0000FFFF) | (c << 16);
                         if (time < M_WHOLE) {
                            ProgCh [chan] = c;
//DBG("`s: ProgChange Chan=`d `s.`06x\r\n",
//TmS (TMS,time), chan+1, MProg [c], prog [chan]);
                         }
                         Pr [NPr].chan = chan;
                         Pr [NPr].prog = prog [chan];
                         Pr [NPr].time = time;
                         NPr++;
                         Ev [NEv].ctrl = MC_PROG;
                      // Ev [NEv].valu = prog [chan] >> 8;
                      // Ev [NEv].val2 = prog [chan] & 0x00FF;
                         NEv++;
                         break;
            case M_PRSS: Ev [NEv].ctrl = MC_PRSS;
                         Ev [NEv].valu = c;
                         NEv++;
                         break;
            case M_PBND: Ev [NEv].ctrl = MC_PBND;
                         GetByt (& p, l, & tc);   if (Bad) return;
                         Ev [NEv].valu = tc;
                         Ev [NEv].val2 = c;
                         NEv++;
                         break;
            case M_CTRL: GetByt (& p, l, & tc);   if (Bad) return;
                         Ev [NEv].valu = tc;
                      // bankMLB,LSB only stored in prog[], not Ev[]
                         if      (c == M_BANK) {             // Bank
                            if ((chan & 0x0F) == 9)  break;  // no drum ProgCh's
                            prog [chan] = (prog [chan] & 0x00FF00FF) | (c << 8);
                            break;
                         }
                         else if (c == M_BNKL) {             // BankLo
                            if ((chan & 0x0F) == 9)  break;  // no drum ProgCh's
                            prog [chan] = (prog [chan] & 0x00FFFF00) | c;
                            break;
                         }
                      // rpn,nrpn are (only) a mode to pick REAL ctrl#
                         else if ((c >= M_NRPNL) && (c <= M_RPNH)) {
                            regParm [chan][c-M_NRPNL] = tc;
                            regParm [chan][4] = (c >= M_RPNL) ? 1 : 0;
                            break;
                         }
                         else if ((c == M_DATH) || (c == M_DATL)) {
                           uword cno;
                            if (regParm [chan][4]) {  // rp
                               cno = regParm [chan][2] + regParm [chan][3]*128;
                               if (cno >= 8192)  break;
                               Ev [NEv].ctrl |= MC_RP;
                            }
                            else {                    // np
                               cno = regParm [chan][0] + regParm [chan][1]*128;
                               if (cno >= 16382)  break;
                               Ev [NEv].ctrl |= MC_NP;
                            }
                            Ev [NEv].ctrl |= (cno << 1) |
                                             ((c == M_DATL) ? 1 : 0);
                            NEv++;
                            break;
                         }
                         else {
//DBG("  cc `02x", c);
                            Ev [NEv].ctrl = MC_CC | c;
                            NEv++;
                         }
                         break;
            default:
StrFmt (FsBuf,"Trk2Ev time=`s ofs=`d pStat=$`02x badMIDIevent=$`02x",
TmS (TMS,time), MidPos+p, (int) pStat, (int) c);
                         return Puke (FsBuf);
         }
         if (NEv >= BITS (Ev))
            return Puke ("Trk2Ev Hit max output events...:(");
      }
   }
   StrCp (Tr.name, trknm);
//DBG("} Trk2Ev");
}


//______________________________________________________________________________
// section names
// init-ers (within bar 1)    no notes (or portamento) in these
//    SFF1
//       tsig; tmpo; copyright; mark=SFF1; trackname; sysex:
//    SInt
//       F0 7E 7F 09 01 F7   midi on sysex
//       cc vol;  cc rvrb;  cc chor;  bank msb;  bank lsb;  progch;  sysex:
// regular-ers   (bar 2 and on;
//                no rpn,nrpn,data entry,attack/release time ccs in these)
//    Intro A    (B,C,D=rare)
//    Main A     (B,C,D)
//    Fill In AA (BB,CC,DD,BA=Break,AB=rare)
//    Ending A   (B,C,D=rare)

// destination channels                   allowed notes for default C M7
//  9=sub rhythm  2ndary drums            all
// 10=rhythm      main drums              all
// 11=bass                                c,d,e,g,a,b  (all if intro/ending
// 12=chord 1     often rhythm guitar     c,  e,g,  b   and no transposing)
// 13=chord 2     often piano             c,  e,g,  b   "
// 14=pad         often violins,strings   c,  e,g,  b   "
// 15=phrase 1    often brass             c,d,e,g,a,b   "
// 16=phrase 2    often brass             c,d,e,g,a,b   "
char *DChn [] = {
   "=rhy1",  "=rhy2",  "=bass",  "=chd1",  "=chd2",  "=pad ",  "=phr1",  "=phr2"
};

// chordtype bitmap
// byte 0  bit 7-4 = unused, always 0
//         bit 3 = ? (maybe unused?)   (drum only)
//         bit 2 = autostart enable    (drum only)start playing when key hit
//         bit 1 = 1+2+5       bit 0 = sus4               (^if sync start is on)
// byte 1  bit 7 = 1+5         bit 6 = 1+8
//         bit 5 = 7aug        bit 4 = Maj7aug
//         bit 3 = 7(#9)       bit 2 = 7(b13)
//         bit 1 = 7(b9)       bit 0 = 7(13)
// byte 2  bit 7 = 7#11        bit 6 = 7(9)
//         bit 5 = 7b5         bit 4 = 7sus4
//         bit 3 = 7th         bit 2 = dim7
//         bit 1 = dim         bit 0 = minMaj7(9)
// byte 3  bit 7 = minMaj7     bit 6 = min7(11)
//         bit 5 = min7(9)     bit 4 = min(9)
//         bit 3 = m7b5        bit 2 = min7
//         bit 1 = min6        bit 0 = min
// byte 4  bit 7 = aug         bit 6 = Maj6(9)
//         bit 5 = Maj7(9)     bit 4 = Maj(9)
//         bit 3 = Maj7#11     bit 2 = Maj7
//         bit 1 = Maj6        bit 0 = Maj

char *SrcQual [] = {
   "maj",    "6",     "M7",    "M7#11",  "2",     "M9",   "6,9",    "aug",
   "m",      "m6",    "m7",    "m7b5",   "m2",    "m9",   "m7,11",  "mM7",
   "mM7,9",  "dim",   "dim7",  "7",      "7sus",  "7b5",  "9",      "7#11",
   "7,13",   "7b9",   "7b13",  "7#9",    "M7#5",  "7#5",  "oct",    "5",
   "sus",    "sus2",  "off"
};


// NTR
// 0=rootTransposition  same inv of chord is used (for melodic lines)
// 1=rootFixed          notes kept close to prev note range
//                      (for chordal parts like rhythm guitar)
// 2?=guitar            notes transposed to approx chords played with natural
//                      guitar fingering
char *TrnRule [] = {
   "",             // "rootTransp",
   ".vxLead",      // "rootFixed",
   ".guitar"
};


// NTT values - note transposition table - method to use for source transposing
// 0=Bypass  no transposition - ignore played chord.  Must be used for drum chn
//           sometimes for intros,endings
// 1=Melody  use for melodic channels like 15,16 - phrase 1,2
// 2=Chord   use for chord channels like 12,13 - chord 1,2 (piano,guitar)
// 3=Bass    use for 11=bass;  like melody but "on-bass" chords allowed in
//           "fingered 2" fingering mode
// 4=Melodic Minor   use for melodic channels like 15,16 where only major/minor
//                   chords are played like intros,endings
//                   lowers the 3rd when chord changes from M to m
//                   raises when from m to M.  other notes unchanged
// 5=Harmonic Minor  use for chord channels like 12,13
//                   lowers/raises only the 3rd and 6th
// these are only in Cntt  (bass=on means recog on-bass chords allowed in
//                          fingered on bass mode regardless of NTT setting)
// 6=Harmonic Minor 5th var - aug,dim chords affect the 5th
// 7=Natural Minor          - affects 3,6,7th
// 8=Natural Minor 5th var
// 9=Dorian Minor           - affects 3,7th
// A=Dorian Minor 5th var
// for guitar NTR:  all purpose(both stroke+arp)
//                  stroke(some notes sound muted);
//                  arpeggio(4 note arpeggios)
char *TrnTbl [] = {
   "OFF",          // Bypass
   "Melody",
   "Chord",
   "Melody",       // bass=Melody w bassOn
   "MeloMin",
   "HarmMin"
};
char *TrnTbl2 [] = {
   "OFF",          // if bass=off, not defined
   "Melody",       // "  (Melody/Bass)
   "Chord",        // "
   "MeloMin",      // "
   "MeloMin5",
   "HarmMin",      // "
   "HarmMin5",
   "NatrMin",
   "NatrMin5",
   "Dorian",
   "Dorian5",
   "guitarBoth",
   "guitarStroke",
   "guitarArpegg"
};


// RTR values - retrigger rule - how notes behave thru chord change
// 0=Stop
// 1=Pitch shift          pitchbend to match type of new chord
// 2=Pitch shift to root  pitchbend to root of new chord
// 3=Retrigger            new note to match type of new chord
// 4=Retrigger to root    new to to root of new chord
// 5=Note generator       only if programmed in original style
//                        pitch,dur,velo matching new chord
char *ReTrig [] = {
   " retrig=stop",
   "",             // default is bend
   " retrig=bend2root",
   " retrig=note",
   " retrig=note2root",
   " retrig=noteGen"
};


typedef struct {
   ubyte len;
   ubyte srcChn;                       // 0-15
   char  name [8];                     // not \0 term'd, space padded
   ubyte dstChn,                       // 8-15
         rdonly,                       // 1=not editable, 0=editable
         ntMute [2],                   // byte 0 bit 3-0=B-G#  1=play accomp
                                       // byte 1 bit 7-0=G-C   usually 0FFF
         chdMute [5],                  // chordtype bitmap (above)
         srcRoot,                      // 0-11=C..B  root of src chn  dflt: 0=C
         srcQual,                      // 0-34       qual of src chan dflt: 2=M7
         transRule,                    // (NTR) 0=rootTrans;  1=rootFixed
         transTbl,                     // (NTT) 0-5 (above)
         keyHi,                        // (when NTR=0)  roots above mvd oct down
                                       // often 6=F#
         ntLo,                         // outside this range notes moved within
         ntHi,                         //    at least an octave
         retrig,                       // (RTR) retrigger rule - how notes held
                                       // thru chord are handled
         x [40],                       // special features (0=none,
         ntt2;                         // 1=extra break drum voice in Fill In BA
} CtabDef;         // 27 bytes long for x[0]==0
                   // len=37 means 10 extra bytes?
struct CsegDef {
   ulong   map;    // A=0,B=1,C=2,D=3,BA=4 << 2 | 0=main,1=fill,2=intro,3=outro
   ubyte  nChn;
   CtabDef chn [16];
}      Seg [80];
ulong NSeg;

ulong NN [66636];

void SumInit ()   {MemSet (NN, 0, sizeof (NN));}
void SumBump (uword cc)   {NN [cc]++;}
bool SumGot  ()    // got note?
{  for (ulong i = 0; i < 128; i++)  if (NN [i])  return true;
   return false;
}
void SumDump (char *pre)
{ char tmp [8000];
  TStr ts, t2;
   StrCp (tmp, pre);
   for (ulong i = 0; i < BITS (NN); i++)  if (NN [i]) {
      if (i < 128)      // note else ctrl
            StrFmt (ts, " `s", MKey2Str (t2, (ubyte)i));//, NN [i]);
      else  StrFmt (ts, " `s", MCtl2Str (t2, (uword)i));//, NN [i]);
      StrAp (tmp, ts);
   }
//DBG(tmp);
}


//______________________________________________________________________________
ulong MapBit (char *in)
{ ubyte sct, var, lx;
  TStr  ts;
  char *c;
   StrCp (ts, in);   while (c = StrCh (ts, ' '))  *c = '_';
   while (ts [0] == '_')  StrCp (ts, & ts [1]);
   while (StrLn (ts) && (ts [StrLn (ts)-1] == '_'))  ts [StrLn (ts)-1] = '\0';
   var = 9;
   if      (! MemCm (ts, "Main_",   lx = 5))  sct = 0;
   else if (! MemCm (ts, "Fill_In_",     8)) {sct = 1;
      if      (! StrCm (& ts [8], "AA", 2))   var = 0;
      else if (! StrCm (& ts [8], "BB", 2))   var = 1;
      else if (! StrCm (& ts [8], "CC", 2))   var = 2;
      else if (! StrCm (& ts [8], "DD", 2))   var = 3;
      else if (! StrCm (& ts [8], "AB", 2))   var = 4;     // eh, w n x ??
      else if (! StrCm (& ts [8], "BA", 2))   var = 5;     // x
      else  return 99;
   }
   else if (! MemCm (ts, "Break_",       6)) {sct = 0;
      if      (! StrCm (& ts [6], "AA", 2))   var = 4;     // w,x,y,z ??
      else if (! StrCm (& ts [6], "BB", 2))   var = 5;
      else if (! StrCm (& ts [6], "CC", 2))   var = 6;
      else if (! StrCm (& ts [6], "DD", 2))   var = 7;
      else  return 99;
   }
   else if (! MemCm (ts, "Intro_",  lx = 6))  sct = 2;
   else if (! MemCm (ts, "Ending_", lx = 7))  sct = 3;
   else  return 99;
   if (var == 9)  var = CHUP (ts [lx]) - 'A';
   return var*4 + sct;
}


//______________________________________________________________________________
typedef struct {ulong len;  uword fmt, ntrk, res;} MTHdDef;
MTHdDef MTHd;


void MThd (ulong len)
{  if (len < 6)  return Puke ("invalid MThd chunk");
   MTHd.len  = len;
   MTHd.fmt  = Mid [MidPos+0]<<8 | Mid [MidPos+1];
   MTHd.ntrk = Mid [MidPos+2]<<8 | Mid [MidPos+3];
   MTHd.res  = Mid [MidPos+4]<<8 | Mid [MidPos+5];
//DBG("res=`d", MThd.res);
   if (MTHd.ntrk != 1)  Puke ("need exactly one track in style file");
}


void MTrk (ulong len)
{  Trk2Ev (MTHd.res, len);   if (Bad) return;

// map which section/variations we got and their start/end times
  ulong m, b, e, tb, te;
   b = M_WHOLE * TSigN / TSigD;        // bar dur
   if (Tr.end % b)  Tr.end = Tr.end / b * b + b;      // bring end to next bar
   for (m = 0;  m < NMk;  m++)  if ((b = MapBit ((char *)Mk [m].s)) != 99) {
      ScVa [b].tBgn = tb = Mk [m].time;
      ScVa [b].tEnd = te = (m+1 < NMk) ? Mk [m+1].time : Tr.end;
      for (e = 0;  e < NEv;  e++)  if (Ev [e].time >= tb)  break;
      if (e < NEv) {
         ScVa [b].eBgn = e;
         for (;  e < NEv;  e++)  if (Ev [e].time >= te)  break;
         ScVa [b].eEnd = e;
      }
//TStr y, z;
//DBG("bit=`d t=`s-`s e=`d-`d  (end=`s)",
//b, TmS (TMS, ScVa [b].tBgn), TmS (z, ScVa [b].tEnd),
//ScVa [b].eBgn, ScVa [b].eEnd, TmS (y, Tr.end));
   }
}


void CASM (ulong len)
{ ulong p, q, ln, ln2, b;
  ubyte chn, *pf, *pt;
  TStr  ch, ts;
  char *c;
   NSeg = 0;
   for (p = 0;  p < len;  p += ln) {
      MemCp (ch, & Mid [MidPos+p], 4);   ch [4] = '\0';
      ln = Mid [MidPos+p+4]<<24 | Mid [MidPos+p+5]<<16 |
           Mid [MidPos+p+6]<< 8 | Mid [MidPos+p+7];
      p += 8;
//DBG(" `s ln=`d", ch, ln);
      if (! StrCm (ch, "CSEG", 'x')) {
         Seg [NSeg].nChn = 0;
         for (q = 0;  q < ln;  q += ln2) {
            MemCp (ch, & Mid [MidPos+p+q], 4);   ch [4] = '\0';
            ln2 = Mid [MidPos+p+q+4]<<24 | Mid [MidPos+p+q+5]<<16 |
                  Mid [MidPos+p+q+6]<< 8 | Mid [MidPos+p+q+7];
//DBG("  `s ln2=`d", ch, ln2);
            q += 8;
            if      (! StrCm (ch, "Sdec", 'x')) {
               MemCp (ts, & Mid [MidPos+p+q], ln2);   ts [ln2] = '\0';
//DBG("   `s", ts);
               Seg [NSeg].map = 0;
               while (c = StrCh (ts, ',')) {
                  *c = '\0';
                  b = MapBit (ts);
                  if (b == 99)  return Puke ("unknown segment type", ts);
                  Seg [NSeg].map |= (1 << b);
                  StrCp (ts, c+1);
               }
               if (*ts) {
                  b = MapBit (ts);
                  if (b == 99)  return Puke ("unknown segment type", ts);
                  Seg [NSeg].map |= (1 << b);
               }
            }
            else if ((! StrCm (ch, "Ctab", 'x')) ||
                     (! StrCm (ch, "Ctb2", 'x'))) {
               Seg          [NSeg].chn [Seg [NSeg].nChn].len = (ubyte)ln2;
               MemCp (& Seg [NSeg].chn [Seg [NSeg].nChn].srcChn,
                      & Mid [MidPos+p+q],  ln2);
               if (! StrCm (ch, "Ctb2", 'x')) {
                  pt = & Seg [NSeg].chn [Seg [NSeg].nChn].srcChn;
                  pf = & Mid [MidPos+p+q];
                  MemCp (& pt [20], & pf [22], 6);    // just use 1/3
                  MemCp (& pt [26], & pf [41], 6);    // scoot spec features
                  Seg [NSeg].chn [Seg [NSeg].nChn].ntt2 = 1;
               }
               Seg [NSeg].nChn++;
            }
            else if (! StrCm (ch, "Cntt", 'x')) {
//DBG("   ch=`d bass=`s trans=`s",
//Mid [MidPos+p+q+0]+1,
//Mid [MidPos+p+q+1] & 0x80 ? "on":"off", TrnTbl2 [Mid [MidPos+p+q+1] & 0x7F]);
               for (chn = 0;  chn < Seg [NSeg].nChn;  chn++)
                  if (Mid [MidPos+p+q] ==
                      Seg [NSeg].chn [chn].srcChn) {
                     Seg [NSeg].chn [chn].transTbl = Mid [MidPos+p+q+1];
                     Seg [NSeg].chn [chn].ntt2     = 1;
                     break;
                  }
               if (chn >= Seg [NSeg].nChn)
                  return Puke ("couldn't match Cntt to Ctab");
            }
         }
         NSeg++;
      }
   }
}


//______________________________________________________________________________
void Save ()
{ ubyte sc, va, pa, s, c, nt;
  ulong mp, e, tb, te, ne, dur, dr;
  TStr  ts, fno, trn, tr, sn, ln;
  File  f;
  char  x [800];
  bool  part [4];
  struct {bool got;  ubyte part;  TStr tr, sn;} co [16];
  CtabDef *t;
   for (sc = 0;  sc < 4;  sc++) {      // main,fill,intro,outro
      for (va = 0;  va < 8;  va++) {   // a,b,c,d,w,x,y,z
         mp = 1 << (va*4 + sc);
         tb = ScVa [va*4 + sc].tBgn;
         te = ScVa [va*4 + sc].tEnd;

      // find our seg for this sc/va
         for (s = 0;  s < NSeg;  s++)  if (Seg [s].map & mp)  break;
         if (s >= NSeg)  continue;     // don't got us? - NEXT !!

//DBG("seg=`d/`d sc=`d va=`d mp=`06x time=`s beats=`d",
//s, NSeg, sc, va, mp, TmS(TMS,tb), (te-tb)/M_WHOLE*TSigD);
         MemSet (co,   0, sizeof (co));     // wipe output
         MemSet (TE,   0, sizeof (TE));
         MemSet (NTE,  0, sizeof (NTE));
         MemSet (part, 0, sizeof (part));

         for (c = 0;  c < Seg [s].nChn;  c++) {
         // collect up our channels (tracks)
            t =         & Seg [s].chn [c];

         // check that the ctab doesn't have probs
         // chan,name
            x [0] = ' ';   MemCp (& x [1], t->name, 8);
            FixStr1 ((ubyte *)(& x [1]), 8);
            *tr = '\0';   StrCp (trn, & x [1]);
            while (StrLn (trn) && (trn [StrLn (trn)-1] == ' '))
               StrAp (trn, "", 1);

            if (t->dstChn >= 16) {
               StrFmt (x, "seg `d chn `d has dstChn=`d", s, c, t->dstChn);
               return Puke (x);
            }
            StrFmt (& x [StrLn (x)], " `>2d", t->dstChn+1);
            if ((t->dstChn >= 8) && (t->dstChn <= 15))
                  StrAp (x, DChn [t->dstChn-8]);
            else  StrAp (x, "=????");
            if (t->srcChn != t->dstChn) {
               if (t->srcChn >= 16) {
                  StrFmt (x, "seg `d chn `d has srcChn=`d",
                           s, c, t->dstChn);
                  return Puke (x);
               }
               StrFmt (& x [StrLn (x)], "(`d)", t->srcChn+1);
            }
            if (   t->transTbl  || (t->dstChn <  8) || (t->dstChn >  9))
               if (ProgCh [t->srcChn] >= 128) {
                  StrFmt (x, "seg `d chn `d has ProgCh=`d",
                           s, c, ProgCh [t->srcChn]);
                  return Puke (x);
               }
            StrFmt (& x [StrLn (x)], " `s",
               ((! t->transTbl) && (t->dstChn >= 8) && (t->dstChn <= 9))
               ? "Drum\\Drum" : MProg [ProgCh [t->srcChn]]);
            StrCp (sn,
               ((! t->transTbl) && (t->dstChn >= 8) && (t->dstChn <= 9))
               ? "Drum\\Drum" : MProg [ProgCh [t->dstChn]]);

         // NTT,NTR,autostart,etc
           bool bass = false, ntr = false;
            if (t->ntt2) {
               bass = (t->transTbl & 0x80) ? true : false;
               if ((t->transTbl & 0x7F) >= BITS (TrnTbl2)) {
                  StrFmt (x, "seg `d chn `d has NTT2=`d",
                           s, c, t->transTbl & 0x7F);
                  return Puke (x);
               }
               switch (t->transTbl & 0x7F) {
                  case 0:
                  case 1:  ntr = false;   break;
                  default: ntr = true;
               }
            }
            else {
               if (t->transTbl >= BITS (TrnTbl)) {
                  StrFmt (x, "seg `d chn `d has NTT=`d", s, c, t->transTbl);
                  return Puke (x);
               }
               switch (t->transTbl) {
                  case 0:                           // bypass
                  case 1:                break;     // melody
                  case 2: ntr  = true;   break;     // chord
                  case 3: bass = true;   break;     // bass
                  case 4:                           // meloMin
                  case 5: ntr  = true;   break;     // harmMin
               }
            }
            if (t->transRule >= BITS (TrnRule)) {
               StrFmt (x, "seg `d chn `d has NTR=`d", s, c, t->transRule);
               return Puke (x);
            }
            StrFmt (& x [StrLn (x)], " trans=`s`s`s`s",
               t->ntt2 ? TrnTbl2 [t->transTbl & 0x7F] : TrnTbl [t->transTbl],
               ntr  ? TrnRule [t->transRule] : "",
               bass ? "(bass=on)"            : "",
               (t->chdMute[0] & 0x04) ? " autostart" : "");

         // mute on note,chordtype
            if ((t->ntMute [0] != 0x0F) || (t->ntMute [1] != 0xFF)) {
               StrFmt (& x [StrLn (x)],   " rootMap=`01x`02x",
                                          t->ntMute[0], t->ntMute[1]);
               StrFmt (tr, " ?r`01x`02x", t->ntMute[0], t->ntMute[1]);
            }
            if (((t->chdMute[0] & 0x03) != 0x03) ||
                (t->chdMute[1] != 0xFF) || (t->chdMute[2] != 0xFF) ||
                (t->chdMute[3] != 0xFF) || (t->chdMute[4] != 0xFF)) {
               StrFmt (& x [StrLn (x)],   " chordmap=`01x.`02x`02x.`02x`02x",
                  t->chdMute[0] & 0x01, t->chdMute[1], t->chdMute[2],
                  t->chdMute[3], t->chdMute[4]);
               StrFmt (& tr [StrLn (tr)], " ?`01x.`02x`02x.`02x`02x",
                  t->chdMute[0] & 0x01, t->chdMute[1], t->chdMute[2],
                  t->chdMute[3], t->chdMute[4]);
            }

         // source root,chordtype
            if (t->srcRoot >= 12) {
               StrFmt (x, "seg `d chn `d has srcRoot=`d",
                  s, c, t->srcRoot);
               return Puke (x);
            }
            if (t->srcQual >= BITS (SrcQual)) {
               StrFmt (x, "seg `d chn `d has srcQuality=`d",
                  s, c, t->srcQual);
               return Puke (x);
            }
            if (t->srcQual != 2) {
               StrFmt (& x [StrLn (x)], " chord=`s", SrcQual [t->srcQual]);
               StrFmt (& tr [StrLn (tr)], " @`s@",   SrcQual [t->srcQual]);
            }

         // note range if picked
            if ((t->ntLo > M_NT(M_A,0)) || (t->ntHi < M_NT(M_C,8))) {
               StrAp (x, " ntRng=");
               if (t->ntLo > M_NT(M_A,0))  StrAp (x, MKey2Str (ts, t->ntLo));
               StrAp (x, "-");
               if (t->ntLo < M_NT(M_C,8))  StrAp (x, MKey2Str (ts, t->ntHi));
            }

         // keyHi,retrig(RTR)
            if (t->keyHi >= 12) {
               StrFmt (x, "seg `d chn `d has keyHigh=`d",
                  s, c, t->keyHi);
               return Puke (x);
            }
            StrFmt (& x [StrLn (x)], " keyHi=`s", MKeyStr [t->keyHi]);
            if (t->retrig != 1) {
               if (t->retrig < BITS (ReTrig))  StrAp (x, ReTrig [t->retrig]);
               else {
                  StrFmt (x, "seg `d chn `d has retrig=`d",
                     s, c, t->retrig);
                  return Puke (x);
               }
            }

         // extra stuffz
            if (t->x [0]) {
               StrFmt (& x [StrLn (x)], " x=$`02x",  t->x [0]);
               for (ubyte z = 27; z < t->len;  z++)
                  StrFmt (& x [StrLn (x)], " $`02x", t->x [z-26]);
            }
            if      ((! t->transTbl) && (t->dstChn >= 8) &&
                                        (t->dstChn <= 9))
                            {co [c].part = 3;   StrAp (x, " DRUM");}
            else if (bass)  {co [c].part = 2;   StrAp (x, " BASS");}
            else if (ntr)   {co [c].part = 1;   StrAp (x, " CHRD");}
            else            {co [c].part = 0;   StrAp (x, " MELO");}
            StrCp (co [c].tr, trn);   StrAp (co [c].tr, tr);
            StrCp (co [c].sn, sn);

         // gather sc,va's chan's events
            SumInit ();
//          for (e = 0;  e < NPr;  e++)
//             if ((Pr [e].chan == t->srcChn) && (Pr [e].time >= tb) &&
//                                               (Pr [e].time <  te))
//DBG("   `s ProgCh `d `s $`06x",
//TmS (TMS, Pr [e].time-tb), Pr [e].chan+1,
//MProg [(Pr [e].prog >> 16) & 0x7F], Pr [e].prog);

            for (e = 0;  e < NEv;  e++)
               if ((Ev [e].chan == t->srcChn) && (Ev [e].time >= tb) &&
                                                 (Ev [e].time <  te)) {
                  SumBump (Ev [e].ctrl - t->srcRoot);
                  if (! (Ev [e].ctrl & 0xFF80)) {
                     TE [c][NTE [c]].time = Ev [e].time - tb;
                     nt = (ubyte)Ev [e].ctrl - t->srcRoot;
                     while (nt < t->ntLo) nt += 12;
                     while (nt > t->ntHi) nt -= 12;
                     TE [c][NTE [c]].ctrl = nt;
                     TE [c][NTE [c]].valu = Ev [e].valu;
                     NTE [c]++;
                  }
//DBG("     ch=`d `s `02x `02x",
//Ev [e].chan, TmS (TMS, Ev [e].time-tb), Ev [e].ctrl, Ev [e].valu);
               }
            if (SumGot ())             // track name from chdMute n t->name
               {SumDump (x);   part [co [c].part] = co [c].got = true;}
         }                             // end chan

         if (part [0] || part [1] || part [2] || part [3]) {
            App.Path (fno, 'd');   StrAp (fno, "\\clip\\");
            switch (sc) {
               case 0:  StrAp (fno, "main\\");    break;
               case 1:  StrAp (fno, "fill\\");    break;
               case 2:  StrAp (fno, "intro\\");   break;
               default: StrAp (fno, "outro\\");   break;
            }
//DBG("tb=`d te=`d tsN=`d tsD=`d FN=`s", tb, te, TSigN, TSigD, FN);
            dr = (te - tb) / (M_WHOLE * TSigN / TSigD);
            if (((te - tb) % (M_WHOLE * TSigN / TSigD)) >
                             (M_WHOLE * TSigN / TSigD / 2))  dr++;
            StrAp (fno, StrFmt (ts, "`d.`d_`d_", TSigN, TSigD, dr));
            FnName (ts, FN);   StrAp (ts, "", 4);
            StrFmt (& fno [StrLn (fno)], "`s_`c.song", ts, "abcdwxyz" [va]);
            StrCp (ts, fno);   Fn2Path (ts);   f.PathMake (ts);

            if (! f.Open (fno, "w"))  Die ("can't write file", fno);

         // get dur,ne
            dur = (te - tb) / (M_WHOLE * TSigN / TSigD);
            for (pa = 0;  pa < 4;  pa++)  if (part [pa]) {
               if (pa < 3) {
                  for (c = 0;  c < Seg [s].nChn;  c++)
                     if (co [c].got && (co [c].part == pa))
                        {ne = NTE [c];   break;}
               }
               else {                  // drums are special - only 1 track
                  for (ne = 0, c = 0;  c < Seg [s].nChn;  c++)
                     if (co [c].got && (co [c].part == pa))  ne += NTE [c];
               }
            }
            f.Put ("Track:\r\n");
            for (pa = 0;  pa < 4;  pa++)  if (part [pa]) {
               if (pa < 3) {
                  for (c = 0;  c < Seg [s].nChn;  c++)
                     if (co [c].got && (co [c].part == pa)) {
                        StrCp (tr, co [c].tr);
                        StrCp (ts, ".");
//                      if (c && (Seg [s].chn [c-1].dstChn ==
//                                Seg [s].chn [c].dstChn))  *ts = '+';
                        StrFmt (ln, ".  `s  `d  `d  `s",
                                co [c].sn, ne, dur, ts);
                        switch (pa) {
                           case 0:  StrAp (ln, "melo");   break;
                           case 1:  StrAp (ln, "chrd");   break;
                           case 2:  StrAp (ln, "bass");   break;
                        }
                        StrAp (ln, *tr ? " " : "");
                        StrAp (ln, tr);
                        StrAp (ln, "\r\n");
                        f.Put (ln);
                     }
               }
               else {               // drums are special - only 1 track
                  for (c = 0;  c < Seg [s].nChn;  c++)
                     if (co [c].got && (co [c].part == pa))
                        {f.Put (StrFmt (ln,
                            ".  Drum\\Drum  `d  `d  .DrumTrack\r\n",  ne, dur));
                         break;}
               }
            }
         // write events
            f.Put ("Event:\r\n");
            for (pa = 0;  pa < 4;  pa++)  if (part [pa]) {
               for (c = 0;  c < Seg [s].nChn;  c++)
                  if (co [c].got && (co [c].part == pa)) {


               if (pa < 3) {
                  for (c = 0;  c < Seg [s].nChn;  c++)
                     if (co [c].got && (co [c].part == pa)) {
                        StrCp (tr, co [c].tr);
                        StrCp (ts, ".");
//                      if (c && (Seg [s].chn [c-1].dstChn ==
//                                Seg [s].chn [c].dstChn))  *ts = '+';
                        f.Put (StrFmt (ln, ".  `s  `d  `d  `s",
                           co [c].sn, ne, dur, ts));
                        switch (pa) {
                           case 0:  f.Put ("melo");   break;
                           case 1:  f.Put ("chrd");   break;
                           case 2:  f.Put ("bass");   break;
                        }
                        f.Put (StrFmt (ln, "`s`s\r\n",  (*tr)?" ":"", tr));
                     }
               }
               else {               // drums are special - only 1 track
                  for (c = 0;  c < Seg [s].nChn;  c++)
                     if (co [c].got && (co [c].part == pa))
                        {f.Put (StrFmt (ln,
                            ".  Drum\\Drum  `d  `d  .DrumTrack\r\n",  ne, dur));
                         break;}
               }


      t = St [s].trak;
      if ((St [s].chan & 0x0F) == 9)  StrCp (snnm, "Drum\\Drum");
      else                            StrCp (snnm, MProg [St [s].prog >> 16]);
      Fs.Put (StrFmt (SB, "-- track `d `s `s ne=`d dur=`d\r\n",
         s, Tr [t].name, snnm, St [s].end - St [s].bgn + 1, Tr [t].dur
      ));
      for (e = St [s].bgn;  e <= St [s].end;  e++) {
         Fs.Put (StrFmt (SB, "`s ", TmS (TMS, Ev [e].time)));
         c = Ev [e].ctrl;
         if (c & 0x0080) {             // ctrl
            if (Ev [e].val2)
                  Fs.Put (StrFmt (SB, "cc`d `d `d\r\n",
                                       c & 0x007F, Ev [e].valu, Ev [e].val2));
            else  Fs.Put (StrFmt (SB, "cc`d `d\r\n",
                                       c & 0x007F, Ev [e].valu));
         }
         else                          // note
            Fs.Put (StrFmt (SB, "`s`c`d\r\n",
               ((St [s].chan & 0x0F) == 9) ? MDrm2Str (ts, (ubyte)c)
                                           : MKey2Str (ts, (ubyte)c),
               (Ev [e].valu & 0x0080) ? ((Ev [e].val2 & 0x80) ? '~' : '_')
                                      : '^',  Ev [e].valu & 0x007F));
      }




//                   f.Put (TE [c], sizeof (TrkEv) * ne);
                  }
            }

            f.Shut ();
         }
      }                                // end variation
   }                                   // end section
}


//______________________________________________________________________________
int TabCmp (void *p1, void *p2)
{ int t;
  CtabDef *i1 = (CtabDef *)p1, *i2 = (CtabDef *)p2;
   if (t = i1->dstChn - i2->dstChn)  return t;
   if (t = i1->srcChn - i2->srcChn)  return t;
   return MemCm (i1->name, i2->name, 8);
}

void CvtSty ()
// parse the style file's MThd,MTrk,CASM chunks n write db of style stuphs
{ ulong clen;
  TStr  chnk, ts;
  File  f;
// skip any non sty extensions
   *ts = '\0';
   if (StrLn (FN) > 3)  StrCp (ts, & FN [StrLn (FN)-3]);
   if (! PosInZZ (ts, "sty\0mid\0bcs\0prs\0sst\0pcs\0pst\0fps\0"))  return;

//DBG("{ CvtSty FN=`s", FN);
// wipe for this sty file
   MemSet (ScVa, 0, sizeof (ScVa));   NEv = 0;   NSeg = 0;
   MemSet (& Tr, 0, sizeof (Tr));
   MidPos = NPr = NMk = 0;   TSigN = TSigD = (ubyte)4;   Tmpo [0] = '\0';
   Bad = false;
   if ((MidLen = f.Load (FN, Mid, sizeof (Mid))) == 0)
                               return Puke ("empty file??");
   if (MidLen == BITS (Mid))   return Puke ("file too huge");

// load in known chunks (MThd,CASM only - skip rest)
   for (MidPos = 0;  MidPos < MidLen;) {
      MemCp (chnk, & Mid [MidPos+0], 4);   chnk [4] = '\0';
      clen = Mid [MidPos+4]<<24 | Mid [MidPos+5]<<16 |
             Mid [MidPos+6]<< 8 | Mid [MidPos+7];
//DBG("`s len=`d", chnk, clen);
      MidPos += 8;
      if (MidPos + clen > MidLen)  return Puke ("chunk goes beyond EOF", chnk);

      if      (! StrCm (chnk, "MThd", 'x')) {MThd (clen);   if (Bad) return;}
   // ...sigh...
      else if (! StrCm (chnk, "STYL", 'x')) {MThd (clen);   if (Bad) return;}

      else if (! StrCm (chnk, "MTrk", 'x')) {
      // fix bug in popular .sty writer out there that makes clen 1 too short
        ubyte z[7];  z[0]=0xFF; z[1]=0x2F; z[2]=0x00; MemCp(&z[3],"CASM",4);
         if ( (MidPos+clen+4 < MidLen) &&
              (! MemCm ((char *)(& Mid [MidPos+clen-2]), (char *)z, 7, 'x')) )
            clen++;
                                             MTrk (clen);   if (Bad) return;
      }
      else if (! StrCm (chnk, "CASM", 'x')) {CASM (clen);   if (Bad) return;}

      MidPos += clen;
   }
   for (ubyte s = 0;  s < NSeg;  s++)
      Sort (Seg [s].chn, Seg [s].nChn, sizeof (CtabDef), TabCmp);
   Save ();
//DBG("} CvtSty");
}


//______________________________________________________________________________
TStr Dir, FNm [64*1024];   ulong NFNm;

void Find (char *dir)
// find any song files and put em in _list
{ TStr src, f2, f3;
  TSt2 s2;
  HANDLE          fh;
  WIN32_FIND_DATA ff;
// find it all (FindFirstFile dies if dir ain't there)
   StrFmt (src, "`s\\*.*", dir);
   if ((fh = ::FindFirstFile (StrCvt (s2, src), & ff)) == INVALID_HANDLE_VALUE)
      return;
   do {
      StrFmt (src, "`s\\`s", dir, StrCvt (f2, ff.cFileName));
      if (ff.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
         if (StrCm (StrCvt (f2, ff.cFileName), ".") &&
             StrCm (StrCvt (f3, ff.cFileName), ".."))
            Find (src);
      }
      else {                           // add any files to list
         if (NFNm >= BITS (FNm))  Die ("Find  too many files - bug Steve :(");
         StrCp (FNm [NFNm++], src);
      }
   } while (::FindNextFile (fh, & ff));
   if (! ::FindClose (fh))  DieWn ("Find  FindClose");
}


class ThrSty2Clip: public Thread {
public:
   ThrSty2Clip (Waiter *w): _w (w), Thread (w->wnd)  {}
private:
   Waiter *_w;

   int End ()  {PostDadW (MSG_CLOSE, 0, 0);   return 0;}

   DWORD Go ()
   { ulong i;
     TStr  s, s2;
     MSG   msg;
     File  f;
//DBG("{ ThrSty2Clip::Go `s", _w->arg);
      InitMsgQ ();   msg.message = 0;

   // kill off any existing sty mids
      StrCp (s2, "Deleting existing clip style midis");
      if (_w->Set ( 1, s2))  return End ();
      App.Path (s, 'd');   StrAp (s, "\\clip\\Main");    f.PathKill (s);
      if (_w->Set (25, s2))  return End ();
      App.Path (s, 'd');   StrAp (s, "\\clip\\Fill");    f.PathKill (s);
      if (_w->Set (50, s2))  return End ();
      App.Path (s, 'd');   StrAp (s, "\\clip\\Intro");   f.PathKill (s);
      if (_w->Set (75, s2))  return End ();
      App.Path (s, 'd');   StrAp (s, "\\clip\\Outro");   f.PathKill (s);

      App.Path (Dir, 'd');   StrAp (Dir, "\\clip\\Style");
      NFNm = 0;   Find (Dir);
      for (i = 0;  i < NFNm;  i++) {
         StrFmt (s, "Converting style files...  `d of `d", i+1, NFNm);
         if (_w->Set ((ubyte)(100*i/NFNm), s))  return End ();
         StrCp (FN, FNm [i]);   CvtSty ();
      }
      return End ();
   }
};


class DlgSty2Clip: public Dialog {
public:
   DlgSty2Clip (char *arg): Dialog (IDD_WAIT, IDI_APP), _t (NULL)
                {StrCp (_w.arg, arg);}
  ~DlgSty2Clip ()  {delete _t;}
private:
   ThrSty2Clip *_t;
   Waiter       _w;
   void Open ()  {_w.Init (Wndo ());   _t = new ThrSty2Clip (& _w);}
   void Done ()  {_w.Quit ();   _t->PostKid (WM_CLOSE, 0, 0);}
};


int Go ()
{
TRC("{ Sty2Clip::Go");
   InitCom ();

  DlgSty2Clip dlg ("");
   dlg.Ok (NULL);

   QuitCom ();
TRC("} Sty2Clip::Go");
   return 0;
}
